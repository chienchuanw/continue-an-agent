# Code Review Checklist

## agent-naan × Continue.dev × Claude 4.5

This document provides a **comprehensive code review checklist** for all pull requests.

All items MUST be verified before approval. Violations of critical items are **automatic merge blockers**.

---

## 1. Prompt Contract Compliance

### 1.1 Prompt Structure (CRITICAL)

- [ ] All prompts follow the mandatory structure: `<SYSTEM>` → `<CONTEXT>` → `<TASK>` → `<INPUT>` → `<OUTPUT_CONSTRAINTS>`
- [ ] No sections are omitted unless explicitly allowed by specification
- [ ] System prompt is defined once per session and immutable during runtime
- [ ] System prompt does not reference specific files

### 1.2 Context Section (CRITICAL)

- [ ] Context is ONLY generated by Context Engine (never manually injected)
- [ ] Context follows the required XML structure with `<File>`, `<Metadata>`, and `<Content>` tags
- [ ] Context items are sorted by descending score
- [ ] Same-file items are grouped together
- [ ] Ordering is stable and deterministic

### 1.3 Token Budget (CRITICAL)

- [ ] Token budget allocation follows specification:
  - SYSTEM: fixed
  - CONTEXT: 40-60%
  - TASK: 5-10%
  - INPUT: variable
  - OUTPUT: remainder
- [ ] Hard truncation is enforced (never overflow)
- [ ] Budget calculation includes ALL sections (system, context, task, input)

### 1.4 Prompt Types

- [ ] Chat prompts have no file mutation or tool invocation
- [ ] Edit prompts include diff-only output constraint
- [ ] Agent prompts specify: tool allowlist, max step count, explicit approval requirement

### 1.5 Anti-Patterns (MERGE BLOCKER)

- [ ] No inline prompt concatenation
- [ ] No mixing of context with instructions
- [ ] Model does not decide context
- [ ] No dynamic system prompt mutation

---

## 2. Context Engine Integration

### 2.1 Mandatory Usage (CRITICAL)

- [ ] Context Engine is used for ALL non-trivial requests
- [ ] Context Engine is MANDATORY for:
  - Agent tasks
  - Refactoring operations
  - Bug fixes
  - Multi-file queries
- [ ] No direct file dumping anywhere in the codebase

### 2.2 Retrieval Pipeline

- [ ] Intent classification is performed before retrieval
- [ ] Retrieval strategy is selected based on intent
- [ ] Multiple retrieval methods are used (semantic, lexical, dependency, recent edits)
- [ ] Candidates are ranked and scored correctly
- [ ] Token budget allocation is enforced

### 2.3 Context Engine Constraints

- [ ] Token budgets are respected (hard limit)
- [ ] Prompts are NOT mutated outside Context Engine
- [ ] Deterministic ordering is provided
- [ ] Context is selected, not accumulated

### 2.4 Indexing & Retrieval

- [ ] File contents, AST symbols, import graphs, and git metadata are indexed
- [ ] Semantic search is used as primary relevance method
- [ ] Lexical search is used for identifiers and exact matches
- [ ] Dependency walk is used for call/import relationships
- [ ] Recent edits are used for bug fixing context

### 2.5 Failure Handling

- [ ] No candidates → Falls back to local file
- [ ] Budget overflow → Drops lowest score items
- [ ] Index missing → Warns and rebuilds

---

## 3. Human-in-the-Loop Enforcement

### 3.1 Agent Actions (CRITICAL)

- [ ] All file mutations require explicit user approval
- [ ] Agent explains intent BEFORE action
- [ ] No autonomous file writes
- [ ] Max step count is enforced
- [ ] No silent execution (all actions are visible)

### 3.2 Permission Checks

- [ ] Extension Layer enforces ALL permission checks
- [ ] Core Engine cannot mutate state directly
- [ ] UI is informational only (no execution decisions)
- [ ] Tool invocations go through approval workflow

### 3.3 Tool Registry

- [ ] All agent tools have clear descriptions
- [ ] Input schemas are defined (JSONSchema)
- [ ] Tools are registered in Extension Layer
- [ ] Tool execution requires user approval

### 3.4 Abort & Recovery

- [ ] Agent can abort safely on failure
- [ ] Execution steps are tracked
- [ ] Failed operations are logged
- [ ] User can cancel operations at any time

---

## 4. Module Boundary Violations (MERGE BLOCKER)

### 4.1 Forbidden Dependencies (CRITICAL)

Check for these VIOLATIONS:

- [ ] ❌ Core → Extension (FORBIDDEN)
- [ ] ❌ Core → VSCode UI (FORBIDDEN)
- [ ] ❌ Local Services → Core (FORBIDDEN)
- [ ] ❌ UI → LLM APIs (direct) (FORBIDDEN)
- [ ] ❌ UI → File System (direct) (FORBIDDEN)

### 4.2 Allowed Dependencies

Verify these are CORRECT:

- [ ] ✅ VSCode UI Layer → Extension Layer types only
- [ ] ✅ Extension Layer → Core Engine public API
- [ ] ✅ Core Engine → Local Services

### 4.3 Layer Responsibilities

**VSCode UI Layer:**

- [ ] Only renders chat, tasks, diffs
- [ ] Only displays inline completions
- [ ] Only collects user input
- [ ] Does NOT call LLM APIs
- [ ] Does NOT read project files directly
- [ ] Does NOT make execution decisions

**Extension Layer:**

- [ ] Translates VSCode APIs → Core events
- [ ] Enforces permission checks
- [ ] Executes approved filesystem/shell actions
- [ ] Maintains editor state

**Core Engine:**

- [ ] Is editor-agnostic
- [ ] Contains all intelligence
- [ ] Manages LLM abstraction
- [ ] Orchestrates Context Engine
- [ ] Handles agent runtime

**Local Services:**

- [ ] Provides vector storage (LanceDB)
- [ ] Provides embedding generation
- [ ] Provides sandboxed shell/FS access

### 4.4 Interface Segregation

- [ ] Interfaces are small and focused (not "God interfaces")
- [ ] Each interface has a single responsibility
- [ ] Interfaces follow naming conventions (`ILLMClient`, `IContextRetriever`)

---

## 5. General Code Quality

### 5.1 TypeScript Compliance

- [ ] All code passes `tsc --noEmit` with no errors
- [ ] Strict mode is enabled (`strict: true`)
- [ ] No `any` types (except with documented justification)
- [ ] No type assertions (`as`) without justification in comments
- [ ] Explicit return types for all functions

### 5.2 Naming Conventions

- [ ] Interfaces: PascalCase with `I` prefix (`ILLMClient`)
- [ ] Types: PascalCase without prefix (`ContextQuery`)
- [ ] Classes: PascalCase (`ContextEngine`)
- [ ] Functions: camelCase (`buildPrompt`)
- [ ] Constants: UPPER_SNAKE_CASE (`MAX_TOKEN_BUDGET`)
- [ ] Enums: PascalCase for enum, UPPER_SNAKE_CASE for values
- [ ] Private members: prefix with underscore (`_internalState`)

### 5.3 File Naming

- [ ] Modules: kebab-case (`context-engine.ts`)
- [ ] Interfaces: `.interface.ts` suffix (`llm-client.interface.ts`)
- [ ] Types: `.type.ts` suffix (`context-query.type.ts`)
- [ ] Constants: `.constants.ts` suffix (`retrieval.constants.ts`)
- [ ] Unit tests: `.test.ts` suffix (`context-engine.test.ts`)
- [ ] Integration tests: `.spec.ts` suffix (`integration.spec.ts`)

### 5.4 Import Organization

- [ ] Imports are organized in correct order:
  1. Node built-ins
  2. External dependencies
  3. Internal absolute imports (from `src/`)
  4. Relative imports (same module)

### 5.5 Code Style

- [ ] ESLint shows no errors (`pnpm lint`)
- [ ] Prettier formatting applied (`pnpm format`)
- [ ] No `console.log` statements (use logger)
- [ ] Async/await used correctly (no unhandled promises)
- [ ] Error handling implemented for all async operations

---

## 6. Documentation

### 6.1 TSDoc Comments

- [ ] All public APIs have TSDoc comments
- [ ] Comments include `@param`, `@returns`, `@throws` tags
- [ ] Examples are provided for complex functions
- [ ] Module-level documentation exists for major modules

### 6.2 Inline Comments

- [ ] Comments explain WHY, not WHAT
- [ ] Non-obvious behavior is documented
- [ ] Intentional deviations are marked with justification
- [ ] No redundant comments

### 6.3 README & Documentation

- [ ] Changes to architecture are reflected in `docs/architecture.md`
- [ ] Changes to Context Engine are reflected in `docs/context-engine.md`
- [ ] Changes to prompts are reflected in `docs/prompt-contracts.md`
- [ ] API changes are documented

---

## 7. Tests

### 7.1 Test Coverage

- [ ] All tests pass (`pnpm test`)
- [ ] Minimum 80% coverage for Core Engine modules
- [ ] 100% coverage for critical paths:
  - Context Engine retrieval pipeline
  - Prompt assembly and token budgeting
  - Permission checks and security gates
  - Error handling and recovery

### 7.2 Test Quality

- [ ] Tests follow Arrange-Act-Assert pattern
- [ ] Test names are descriptive (`should return ranked context items for valid query`)
- [ ] Edge cases are tested
- [ ] Error conditions are tested
- [ ] Async operations are tested correctly

### 7.3 Test Organization

- [ ] Unit tests in `**/*.test.ts`
- [ ] Integration tests in `**/*.spec.ts`
- [ ] E2E tests in `test/e2e/`
- [ ] Tests are co-located with source code in `__tests__/` directories

### 7.4 Mocking

- [ ] External dependencies are mocked appropriately
- [ ] Mocks are realistic and maintainable
- [ ] No over-mocking (test real behavior when possible)

---

## 8. Security

### 8.1 Input Validation (CRITICAL)

- [ ] All external inputs are validated
- [ ] Type checking is performed
- [ ] Length limits are enforced
- [ ] File paths are sanitized (no path traversal)
- [ ] User queries are validated

### 8.2 Secrets Management (MERGE BLOCKER)

- [ ] No hardcoded secrets or API keys
- [ ] Environment variables used for configuration
- [ ] VSCode Secret Storage used for user secrets
- [ ] `.env` files are in `.gitignore`
- [ ] No secrets in logs or error messages

### 8.3 Command Execution (CRITICAL)

- [ ] Allowlist-based command execution only
- [ ] No arbitrary command execution
- [ ] Timeout limits enforced
- [ ] Execution logs are returned
- [ ] No destructive operations by default

### 8.4 Data Handling

- [ ] No sensitive data in prompts
- [ ] No PII in logs
- [ ] File access is sandboxed
- [ ] Network requests are validated

---

## 9. Dependencies

### 9.1 Package Management

- [ ] Dependencies added via package manager (pnpm), not manual edits
- [ ] `package.json` changes are justified
- [ ] Lock file (`pnpm-lock.yaml`) is updated
- [ ] No unnecessary dependencies

### 9.2 Version Constraints

- [ ] Dependency versions are pinned or use caret ranges
- [ ] No wildcard versions (`*`)
- [ ] Security vulnerabilities checked (`pnpm audit`)

### 9.3 License Compliance

- [ ] All dependencies have compatible licenses
- [ ] License information is documented

---

## 10. Performance

### 10.1 Async Operations

- [ ] Parallel execution used where possible (`Promise.all`)
- [ ] No unnecessary sequential operations
- [ ] Async iterables used for streams

### 10.2 Caching

- [ ] Expensive operations are cached
- [ ] Cache invalidation is implemented
- [ ] Memory usage is reasonable

### 10.3 Resource Management

- [ ] Resources are disposed properly (`vscode.Disposable`)
- [ ] Event listeners are cleaned up
- [ ] No memory leaks

---

## 11. Error Handling

### 11.1 Custom Errors

- [ ] Domain-specific error classes are used
- [ ] Error messages are descriptive
- [ ] Error context is included
- [ ] Error codes are defined

### 11.2 Error Patterns

- [ ] Fail-fast with context
- [ ] Graceful degradation with logging
- [ ] Result types used for expected failures
- [ ] No swallowed errors

### 11.3 Logging

- [ ] Errors are logged with context
- [ ] Log levels are appropriate (error, warn, info, debug)
- [ ] No sensitive data in logs

---

## 12. Git & Commits

### 12.1 Commit Messages

- [ ] Follow conventional commits format: `<type>(<scope>): <subject>`
- [ ] Types are correct: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`
- [ ] Subject is clear and concise
- [ ] Body explains WHY (if needed)
- [ ] Footer references issues (`Closes #42`, `Fixes #58`)

### 12.2 Branch Naming

- [ ] Branch name follows convention:
  - `feat/<feature-name>`
  - `fix/<bug-name>`
  - `docs/<doc-name>`
  - `refactor/<scope>`

### 12.3 Pull Request

- [ ] PR description is clear and complete
- [ ] Related issues are linked
- [ ] Breaking changes are documented
- [ ] Screenshots/demos included (if UI changes)

---

## 13. CI/CD Checks

All automated checks MUST pass:

- [ ] TypeScript compilation (`tsc --noEmit`)
- [ ] ESLint (`pnpm lint`)
- [ ] Prettier check (`pnpm format:check`)
- [ ] Unit tests (`pnpm test`)
- [ ] Integration tests (`pnpm test:integration`)
- [ ] Coverage threshold (80% minimum)

---

## 14. Merge Blockers

The following are **AUTOMATIC MERGE BLOCKERS**:

- [ ] TypeScript compilation errors
- [ ] ESLint errors (warnings allowed)
- [ ] Test failures
- [ ] Coverage below 80% threshold
- [ ] Module boundary violations
- [ ] Hardcoded secrets
- [ ] Prompt contract violations
- [ ] Missing Context Engine integration (for non-trivial requests)
- [ ] Missing human-in-the-loop approval (for file mutations)

---

## 15. Final Checklist

Before approving, verify:

- [ ] All sections above are checked
- [ ] No merge blockers exist
- [ ] Code follows architectural principles:
  - Context-first, model-second
  - IDE-native, not chatbot-centric
  - Human-in-the-loop by default
  - Strict module boundaries
  - Fail-safe over "smart"
- [ ] Changes align with project roadmap
- [ ] Documentation is updated
- [ ] Tests are comprehensive

---

## 16. Reviewer Notes

**For Reviewers:**

1. Start with merge blockers (sections 1, 4, 8.2)
2. Check architectural compliance (sections 2, 3, 4)
3. Verify code quality (sections 5, 6, 7)
4. Review security and performance (sections 8, 10)
5. Confirm CI/CD passes (section 13)

**For Authors:**

- Use this checklist BEFORE submitting PR
- Self-review against all items
- Fix issues proactively
- Document any intentional deviations

---

**Guiding Principle:**

> **LLMs reason. Context decides. Humans approve.**
>
> Every line of code should respect this principle.

---

**Last Updated:** 2026-01-02
**Version:** 1.0.0
